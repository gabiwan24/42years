<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Zeitleiste (mit externen Logos)</title>
    <!-- Tailwind CSS (für das UI-Overlay) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; background-color: #000; }
    </style>
     <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#FFFFFF',
                        'secondary': '#888888',
                    }
                }
            }
        }
    </script>
</head>
<body>
    <!-- UI-Overlay für die aktuelle Jahresanzeige -->
    <div id="ui-overlay" class="fixed top-4 left-1/2 transform -translate-x-1/2 p-4 bg-black bg-opacity-70 rounded-xl shadow-2xl border border-white/30 z-10">
        <h1 class="text-xl font-bold text-primary text-white">Aktuelles Jahr: <span id="current-year" class="text-3xl">2025</span></h1>
        <p class="text-xs text-secondary mt-1 text-center text-gray-400">Scrollen (Mausrad), Farbe ändern (Leertaste)</p>
    </div>

    <canvas id="timeline-canvas"></canvas>

    <script>
        // --- Globale Variablen für Canvas ---
        const canvas = document.getElementById('timeline-canvas');
        const ctx = canvas.getContext('2d');

        // --- Zeit- und Skalenkonstanten ---
        const MIN_YEAR = 1984;
        const VISUAL_MAX_YEAR = new Date().getFullYear(); // Dynamisches Endjahr
        const Z_DISTANCE = 4000;
        const Z_SCALE = Z_DISTANCE / (VISUAL_MAX_YEAR - MIN_YEAR);

        // --- Hilfsfunktionen für Zeit/Position ---
        function yearToZ(year) {
            const clampedYear = Math.max(MIN_YEAR, year);
            return (VISUAL_MAX_YEAR - clampedYear) * Z_SCALE;
        }

        function zToYear(z) {
            const year = VISUAL_MAX_YEAR - (z / Z_SCALE);
            return Math.max(MIN_YEAR, year);
        }

        // --- Kamera & Projektion ---
        const START_Z = yearToZ(VISUAL_MAX_YEAR) - 150;
        const END_Z = yearToZ(MIN_YEAR) - 150;
        const camera = { x: 0, y: 0, z: START_Z };
        let targetZ = START_Z;
        let focalLength;

        // --- Statusvariablen ---
        let isColorMode = false;

        // --- Responsiveness & Geometrie-Dimensionen ---
        let sideLimit = 100;
        let wallHeight = 100;
        const WALL_DISTANCE = 50; 

        // --- Easing Konstanten ---
        const SCROLL_SENSITIVITY = 1.0;
        const EASE_FACTOR = 0.08;
        
        // --- Sichtbarkeitskonstanten ---
        const VISIBLE_RANGE_YEARS = 7;
        const FADE_RANGE_YEARS = 7;
        
        // --- Datenspeicher ---
        const depthLines = [];
        const logos = [];
        const renderableObjects = [];
        
        // --- Fallback-Daten, falls logos.json nicht geladen werden kann ---
        const fallbackLogoData = [
            { "year": 1988, "name": "Fiktives Projekt A", "description": "Platzhalter A", "logoColor": "https://placehold.co/100x100/FF0000/FFFFFF?text=A", "logoBW": "https://placehold.co/100x100/CCCCCC/000000?text=A", "relX": 0.6, "relY": 0.6 },
            { "year": 1995, "name": "Fiktives Projekt B", "description": "Platzhalter B", "logoColor": "https://placehold.co/100x100/00FF00/FFFFFF?text=B", "logoBW": "https://placehold.co/100x100/CCCCCC/000000?text=B", "relX": -0.6, "relY": 0.4 },
            { "year": 2002, "name": "Fiktives Projekt C", "description": "Platzhalter C", "logoColor": "https://placehold.co/100x100/0000FF/FFFFFF?text=C", "logoBW": "https://placehold.co/100x100/CCCCCC/000000?text=C", "relX": 0.0, "relY": 0.7 },
            { "year": 2010, "name": "Fiktives Projekt D", "description": "Platzhalter D", "logoColor": "https://placehold.co/100x100/FFFF00/000000?text=D", "logoBW": "https://placehold.co/100x100/CCCCCC/000000?text=D", "relX": 0.7, "relY": 0.2 },
            { "year": 2018, "name": "Fiktives Projekt E", "description": "Platzhalter E", "logoColor": "https://placehold.co/100x100/FF00FF/FFFFFF?text=E", "logoBW": "https://placehold.co/100x100/CCCCCC/000000?text=E", "relX": -0.7, "relY": 0.5 }
        ];

        // --- 3D zu 2D Projektionsfunktion ---
        function project(point) {
            const relativeZ = point.z - camera.z;
            if (relativeZ <= 0.1) return null;

            const scale = focalLength / relativeZ;

            const screenX = canvas.width / 2 + point.x * scale;
            const screenY = canvas.height / 2 - point.y * scale;
            return { x: screenX, y: screenY, scale: scale };
        }

        // --- Initialisierung ---
        async function init() {
            document.getElementById('current-year').textContent = VISUAL_MAX_YEAR;

            await loadLogoData();
            generateTimelineData();
            onWindowResize(); 
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('wheel', onMouseWheel, false);
            window.addEventListener('keydown', handleKeyPress);
            animate();
        }
        
        // --- Ladefunktion für JSON und SVGs ---
        async function loadLogoData() {
            let logoDefinitions;
            try {
                // KORREKTUR: Pfad zur JSON-Datei angepasst
                const response = await fetch('../logos.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                logoDefinitions = await response.json();
                if (!logoDefinitions || logoDefinitions.length === 0) {
                    throw new Error('logos.json ist leer oder ungültig.');
                }
                console.log('logos.json erfolgreich geladen.');
            } catch (error) {
                console.warn('Laden von logos.json fehlgeschlagen, verwende Fallback-Daten.', error);
                logoDefinitions = fallbackLogoData;
            }

            try {
                const imagePromises = logoDefinitions.map(def => {
                    const bwPromise = new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = (e) => reject(`Fehler beim Laden von ${def.logoBW}: ${e}`);
                        img.src = def.logoBW;
                    });
                    const colorPromise = new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = (e) => reject(`Fehler beim Laden von ${def.logoColor}: ${e}`);
                        img.src = def.logoColor;
                    });

                    return Promise.all([bwPromise, colorPromise]).then(([imageBW, imageColor]) => {
                         const zPos = yearToZ(def.year);
                         const logoObject = {
                            type: 'logo', z: zPos, year: def.year, size: 30, 
                            relX: def.relX, relY: def.relY, label: def.name,
                            description: def.description, imageBW: imageBW, imageColor: imageColor,
                            currentImage: imageBW 
                         };
                         logos.push(logoObject);
                         renderableObjects.push(logoObject);
                    });
                });

                await Promise.all(imagePromises);
                 console.log('Alle Logo-Bilder erfolgreich geladen.');

            } catch (error) {
                console.error('Fehler beim Laden der Logo-Bilder:', error);
            }
        }

        // --- Geometrie-Daten für Tunnel generieren ---
        function generateTimelineData() {
            const totalVisibleYears = VISUAL_MAX_YEAR - MIN_YEAR;
            for (let i = 0; i <= totalVisibleYears; i++) {
                const year = MIN_YEAR + i;
                const zPos = yearToZ(year);
                
                const lineSet = { type: 'lines', z: zPos, year: year };
                depthLines.push(lineSet);
                renderableObjects.push(lineSet);

                const yearLabel = { type: 'text', z: zPos, year: year, text: String(year), baseFontSize: 4, color: '#888888' };
                depthLines.push(yearLabel);
                renderableObjects.push(yearLabel);
            }
        }
        
        function updateGeometryPositions() {
            const requiredHalfHeight = WALL_DISTANCE * Math.tan((Math.PI / 180 * 75) / 2);
            wallHeight = requiredHalfHeight * 2 * 0.95; 
            sideLimit = requiredHalfHeight * (canvas.width / canvas.height) * 0.95;

            depthLines.forEach(obj => {
                if(obj.type === 'lines') {
                    obj.points = [
                        { x: -sideLimit, y: wallHeight / 2, z: obj.z }, { x: sideLimit, y: wallHeight / 2, z: obj.z },
                        { x: -sideLimit, y: -wallHeight / 2, z: obj.z }, { x: sideLimit, y: -wallHeight / 2, z: obj.z },
                        { x: -sideLimit, y: -wallHeight / 2, z: obj.z }, { x: -sideLimit, y: wallHeight / 2, z: obj.z },
                        { x: sideLimit, y: -wallHeight / 2, z: obj.z }, { x: sideLimit, y: wallHeight / 2, z: obj.z }
                    ];
                } else if (obj.type === 'text') {
                    obj.x = -sideLimit - 10;
                    obj.y = 0;
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            renderableObjects.sort((a, b) => b.z - a.z);

            const cameraYear = zToYear(camera.z);

            renderableObjects.forEach(obj => {
                const relativeZ = obj.z - camera.z;
                if (relativeZ <= 0) return;

                const yearDiff = Math.abs(obj.year - cameraYear);
                let alpha = 1.0;
                if (yearDiff > VISIBLE_RANGE_YEARS) {
                    const fadeAmount = (yearDiff - VISIBLE_RANGE_YEARS) / FADE_RANGE_YEARS;
                    alpha = Math.max(0, 1 - fadeAmount);
                }
                
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                
                if (obj.type === 'lines') {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = Math.max(0.25, 1.25 - (relativeZ / Z_DISTANCE) * 1);
                    ctx.beginPath();
                    for(let i = 0; i < obj.points.length; i += 2) {
                        const p1 = project(obj.points[i]);
                        const p2 = project(obj.points[i+1]);
                        if(p1 && p2) { ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); }
                    }
                    ctx.stroke();
                } else if (obj.type === 'text') {
                    const pos = project({ x: obj.x, y: obj.y, z: obj.z });
                    if (pos) {
                        ctx.fillStyle = obj.color;
                        ctx.font = `${obj.baseFontSize * pos.scale}px Inter`;
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(obj.text, pos.x, pos.y);
                    }
                } else if (obj.type === 'logo') {
                    const x = obj.relX * sideLimit * 0.9;
                    const y = (obj.relY * wallHeight * 0.9) - wallHeight / 2;
                    const pos = project({ x, y, z: obj.z });
                    
                    if (pos && obj.currentImage) {
                        const size = obj.size * pos.scale;
                        ctx.drawImage(obj.currentImage, pos.x - size / 2, pos.y - size / 2, size, size);

                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `${8 * pos.scale}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(obj.label, pos.x, pos.y + size / 2 + (10 * pos.scale));
                    }
                }
            });
            ctx.globalAlpha = 1.0;
        }

        // --- Event Handlers ---
        function handleKeyPress(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                isColorMode = !isColorMode;
                logos.forEach(logo => {
                    logo.currentImage = isColorMode ? logo.imageColor : logo.imageBW;
                });
            }
        }

        function onMouseWheel(event) {
            const scrollAmount = event.deltaY * SCROLL_SENSITIVITY;
            targetZ += scrollAmount;
            targetZ = Math.max(START_Z, Math.min(END_Z, targetZ));
        }

        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const fov_rad = 75 * Math.PI / 180;
            focalLength = (canvas.height / 2) / Math.tan(fov_rad / 2);
            updateGeometryPositions();
        }
        
        function updateState() {
            camera.z += (targetZ - camera.z) * EASE_FACTOR;
            
            const currentYear = zToYear(camera.z);
            const yearElement = document.getElementById('current-year');
            if (yearElement) {
                const yearToDisplay = Math.round(Math.min(VISUAL_MAX_YEAR, Math.max(MIN_YEAR, currentYear)));
                yearElement.textContent = yearToDisplay;
            }
        }

        function animate() {
            updateState();
            draw();
            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>

