<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Zeitleiste (mit externen Logos)</title>
    <!-- Tailwind CSS (für das UI-Overlay) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; background-color: #000; }
    </style>
     <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#FFFFFF',
                        'secondary': '#888888',
                    }
                }
            }
        }
    </script>
</head>
<body>
    <!-- UI-Overlay für die aktuelle Jahresanzeige -->
    <div id="ui-overlay" class="fixed top-4 left-1/2 transform -translate-x-1/2 p-4 bg-black bg-opacity-70 rounded-xl shadow-2xl border border-white/30 z-10">
        <h1 class="text-xl font-bold text-primary text-white">Aktuelles Jahr: <span id="current-year" class="text-3xl">2025</span></h1>
        <p class="text-xs text-secondary mt-1 text-center text-gray-400">Scrollen (Mausrad), Farbe (Leertaste), Raster (Enter)</p>
    </div>

    <!-- Versions- und Zeitstempel-Anzeige -->
    <div id="version-info" class="fixed top-4 right-4 z-10 text-right text-xs text-white/50"></div>

    <canvas id="timeline-canvas"></canvas>

    <script>
        // --- Globale Variablen für Canvas ---
        const canvas = document.getElementById('timeline-canvas');
        const ctx = canvas.getContext('2d');
        const VERSION = '1.2.2'; // Versionsnummer zurückgesetzt

        // --- Zeit- und Skalenkonstanten ---
        const MIN_YEAR = 1984;
        const VISUAL_MAX_YEAR = new Date().getFullYear();
        const Z_DISTANCE = 4000;
        const Z_SCALE = Z_DISTANCE / (VISUAL_MAX_YEAR - MIN_YEAR);

        // --- Hilfsfunktionen für Zeit/Position ---
        function yearToZ(year) {
            const clampedYear = Math.max(MIN_YEAR, year);
            return (VISUAL_MAX_YEAR - clampedYear) * Z_SCALE;
        }

        function zToYear(z) {
            const year = VISUAL_MAX_YEAR - (z / Z_SCALE);
            return Math.max(MIN_YEAR, year);
        }

        // --- Kamera & Projektion ---
        const START_Z = yearToZ(VISUAL_MAX_YEAR) - 150;
        const END_Z = yearToZ(MIN_YEAR) - 150;
        const camera = { x: 0, y: 0, z: START_Z };
        let targetZ = START_Z;
        let focalLength;

        // --- Statusvariablen ---
        let isColorMode = false;
        let mousePos = { x: 0, y: 0 };
        let hoveredLogo = null;
        let viewMode = 'tunnel';
        let transitionProgress = 0;
        let isTransitioning = false;
        
        // --- Responsiveness & Geometrie-Dimensionen ---
        let sideLimit = 100;
        let wallHeight = 100;
        const WALL_DISTANCE = 50; 

        // --- Easing Konstanten ---
        const SCROLL_SENSITIVITY = 1.0;
        const EASE_FACTOR = 0.08;
        const TRANSITION_SPEED = 0.05;
        
        // --- Sichtbarkeitskonstanten ---
        const VISIBLE_RANGE_YEARS = 7;
        const FADE_RANGE_YEARS = 4;
        
        // --- Datenspeicher ---
        const depthLines = [];
        const logos = [];
        const renderableObjects = [];
        const loadedLogoInfo = [];
        
        // --- Fallback-Daten ---
        const fallbackLogoData = [
             { "year": 1988, "name": "Fiktives Projekt A", "description": "Platzhalter A", "logoColor": "https://placehold.co/100x100/FF0000/FFFFFF?text=A", "logoBW": "https://placehold.co/100x100/CCCCCC/000000?text=A", "relX": 0.6, "relY": 0.6, "scale": 1.0 },
             { "year": 1995, "name": "Fiktives Projekt B", "description": "Platzhalter B", "logoColor": "https://placehold.co/100x100/00FF00/FFFFFF?text=B", "logoBW": "https://placehold.co/100x100/CCCCCC/000000?text=B", "relX": -0.6, "relY": -0.4, "scale": 1.2 },
        ];

        // --- Hilfsfunktionen ---
        const lerp = (a, b, t) => a * (1 - t) + b * t;
        const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

        // --- 3D zu 2D Projektionsfunktion ---
        function project(point) {
            const relativeZ = point.z - camera.z;
            if (relativeZ <= 0.1) return null;
            const scale = focalLength / relativeZ;
            const screenX = canvas.width / 2 + point.x * scale;
            const screenY = canvas.height / 2 - point.y * scale;
            return { x: screenX, y: screenY, scale: scale };
        }

        // --- Initialisierung ---
        async function init() {
            document.getElementById('current-year').textContent = VISUAL_MAX_YEAR;
            const versionInfoEl = document.getElementById('version-info');
            if (versionInfoEl) {
                const timestamp = new Date().toLocaleString('de-DE', { dateStyle: 'short', timeStyle: 'short' });
                versionInfoEl.innerHTML = `<span>v${VERSION}</span><br><span>${timestamp}</span>`;
            }

            await loadLogoData();
            logos.sort((a, b) => a.year - b.year);
            generateTimelineData();
            onWindowResize(); 
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('wheel', onMouseWheel);
            window.addEventListener('keydown', handleKeyPress);
            canvas.addEventListener('mousemove', handleMouseMove);
            animate();
        }
        
        // --- Ladefunktion für JSON und SVGs ---
        async function loadLogoData() {
            let logoDefinitions;
            let basePath = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
            const jsonUrl = `${basePath}logos.json?v=${new Date().getTime()}`;

            try {
                const response = await fetch(jsonUrl);
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                const text = await response.text();
                logoDefinitions = JSON.parse(text);
                if (!logoDefinitions || logoDefinitions.length === 0) { throw new Error('logos.json is empty or invalid.');}
                console.log('logos.json successfully loaded.');
            } catch (error) {
                console.warn(`Failed to load '${jsonUrl}', using fallback data.`, error);
                logoDefinitions = fallbackLogoData;
                basePath = ''; 
            }

            const loadImageFromPath = (path) => {
                return new Promise(async (resolve, reject) => {
                    const cacheBuster = `?v=${new Date().getTime()}`;
                    const fullPath = path.startsWith('http') ? path : `${basePath}${path}${cacheBuster}`;
                    try {
                        const response = await fetch(fullPath);
                        if (!response.ok) throw new Error(`HTTP ${response.status} for ${fullPath}`);
                        const svgText = await response.text();
                        const blob = new Blob([svgText], { type: 'image/svg+xml' });
                        const url = URL.createObjectURL(blob);
                        const img = new Image();
                        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
                        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error(`Image onerror for Object URL from ${fullPath}`)); };
                        img.src = url;
                    } catch (fetchError) { reject(fetchError); }
                });
            };

            const imagePromises = logoDefinitions.map(async (def) => {
                try {
                    const [imageBW, imageColor] = await Promise.all([
                        loadImageFromPath(def.logoBW),
                        loadImageFromPath(def.logoColor)
                    ]);
                    const zPos = yearToZ(def.year);
                    const logoObject = {
                        type: 'logo', z: zPos, year: def.year, size: 30, 
                        relX: def.relX, relY: def.relY, label: def.name,
                        description: def.description, imageBW: imageBW, imageColor: imageColor,
                        currentImage: imageBW, scale: def.scale || 1.0 
                    };
                    logos.push(logoObject);
                    renderableObjects.push(logoObject);
                    const hasDims = imageBW.naturalWidth > 0 && imageBW.naturalHeight > 0;
                    loadedLogoInfo.push({ name: def.name, hasDims: hasDims });
                } catch (error) { console.error(`Error processing logo definition for "${def.name}":`, error); }
            });
            await Promise.all(imagePromises);
            console.log('Finished processing all logo definitions.');
        }
        
        function calculateGridPositions() {
            const cols = 10;
            const padding = 50;
            const gridWidth = canvas.width - padding * 2;
            const margin = 20;
            const logoCellSize = (gridWidth - (cols - 1) * margin) / cols;

            logos.forEach((logo, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const x = padding + col * (logoCellSize + margin);
                const y = padding + row * (logoCellSize + margin);
                logo.gridX = x;
                logo.gridY = y;
                logo.gridSize = logoCellSize;
            });
        }

        // --- Geometrie-Daten für Tunnel generieren ---
        function generateTimelineData() {
            const totalVisibleYears = VISUAL_MAX_YEAR - MIN_YEAR;
            for (let i = 0; i <= totalVisibleYears; i++) {
                const year = MIN_YEAR + i;
                const zPos = yearToZ(year);
                const lineSet = { type: 'lines', z: zPos, year: year };
                depthLines.push(lineSet);
                renderableObjects.push(lineSet);
                const yearLabel = { type: 'text', z: zPos, year: year, text: String(year), baseFontSize: 4, color: '#888888' };
                depthLines.push(yearLabel);
                renderableObjects.push(yearLabel);
            }
        }
        
        function updateGeometryPositions() {
            const requiredHalfHeight = WALL_DISTANCE * Math.tan((Math.PI / 180 * 75) / 2);
            wallHeight = requiredHalfHeight * 2 * 0.95; 
            sideLimit = requiredHalfHeight * (canvas.width / canvas.height) * 0.95;
            depthLines.forEach(obj => {
                if(obj.type === 'lines') {
                    obj.points = [
                        { x: -sideLimit, y: wallHeight / 2, z: obj.z }, { x: sideLimit, y: wallHeight / 2, z: obj.z },
                        { x: -sideLimit, y: -wallHeight / 2, z: obj.z }, { x: sideLimit, y: -wallHeight / 2, z: obj.z },
                        { x: -sideLimit, y: -wallHeight / 2, z: obj.z }, { x: -sideLimit, y: wallHeight / 2, z: obj.z },
                        { x: sideLimit, y: -wallHeight / 2, z: obj.z }, { x: sideLimit, y: wallHeight / 2, z: obj.z }
                    ];
                } else if (obj.type === 'text') {
                    obj.x = -sideLimit - 10;
                    obj.y = 0;
                }
            });
            calculateGridPositions();
        }

        // --- Haupt-Zeichenfunktion ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const easedProgress = easeInOutQuad(transitionProgress);
            const cameraYear = zToYear(camera.z);
            hoveredLogo = null;

            // Tunnel-Elemente zeichnen
            ctx.globalAlpha = 1 - easedProgress;
            if (ctx.globalAlpha > 0) {
                renderableObjects.forEach(obj => {
                    if (obj.type === 'logo') return;
                    const relativeZ = obj.z - camera.z;
                    if (relativeZ <= 0) return;
                    const yearDiff = Math.abs(obj.year - cameraYear);
                    if (yearDiff > VISIBLE_RANGE_YEARS + FADE_RANGE_YEARS) return;

                    if (obj.type === 'lines') {
                        const gradientRatio = Math.min(1, yearDiff / VISIBLE_RANGE_YEARS);
                        const colorValue = Math.round(255 - gradientRatio * 255);
                        const colorHex = colorValue.toString(16).padStart(2, '0');
                        ctx.strokeStyle = `#${colorHex}${colorHex}${colorHex}`;
                        
                        ctx.lineWidth = Math.max(0.25, 1.25 - (relativeZ / Z_DISTANCE) * 1);
                        ctx.beginPath();
                        for(let i = 0; i < obj.points.length; i += 2) {
                            const p1 = project(obj.points[i]);
                            const p2 = project(obj.points[i+1]);
                            if(p1 && p2) { ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); }
                        }
                        ctx.stroke();
                    } else if (obj.type === 'text') {
                        const pos = project({ x: obj.x, y: obj.y, z: obj.z });
                        if (pos) {
                            ctx.fillStyle = obj.color;
                            ctx.font = `${obj.baseFontSize * pos.scale}px Inter`;
                            ctx.textAlign = 'right';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(obj.text, pos.x, pos.y);
                        }
                    }
                });
            }
            
            // Logos zeichnen
            logos.forEach(logo => {
                // KORREKTUR: Y-Position ist jetzt zentriert um 0
                const tunnelX = logo.relX * sideLimit * 0.9;
                const tunnelY = logo.relY * (wallHeight / 2) * 0.9;
                
                let tunnelPos = project({ x: tunnelX, y: tunnelY, z: logo.z });
                if (!tunnelPos) { tunnelPos = { x: canvas.width / 2, y: canvas.height / 2, scale: 0 }; }

                const currentX = lerp(tunnelPos.x, logo.gridX + logo.gridSize / 2, easedProgress);
                const currentY = lerp(tunnelPos.y, logo.gridY + logo.gridSize / 2, easedProgress);
                const currentBaseSize = lerp(logo.size * tunnelPos.scale * logo.scale, logo.gridSize * logo.scale, easedProgress);

                let tunnelAlpha = 1.0;
                if (Math.abs(logo.year - cameraYear) > VISIBLE_RANGE_YEARS) {
                    tunnelAlpha = Math.max(0, 1 - (Math.abs(logo.year - cameraYear) - VISIBLE_RANGE_YEARS) / FADE_RANGE_YEARS);
                }
                ctx.globalAlpha = lerp(tunnelAlpha, 1.0, easedProgress);
                if (ctx.globalAlpha < 0.001) return;

                const img = logo.currentImage;
                if (!img) return;

                let aspect = (img.naturalWidth > 0 && img.naturalHeight > 0) ? (img.naturalWidth / img.naturalHeight) : 1.0;
                let w, h;
                if (aspect > 1) { w = currentBaseSize; h = currentBaseSize / aspect; } 
                else { h = currentBaseSize; w = currentBaseSize * aspect; }
                const left = currentX - w / 2;
                const top = currentY - h / 2;
                
                try {
                    ctx.drawImage(img, left, top, w, h);
                } catch (e) { console.error(`Fehler beim Zeichnen von ${logo.label}`, e); }
                
                if (mousePos.x >= left && mousePos.x <= left + w && mousePos.y >= top && mousePos.y <= top + h) {
                    hoveredLogo = logo;
                }
            });
            
            if (hoveredLogo) { drawTooltip(hoveredLogo.description, mousePos.x, mousePos.y); }
            drawDebugInfo();
            ctx.globalAlpha = 1.0;
        }

        function drawTooltip(text, x, y) {
            const maxWidth = 200;
            const lineHeight = 18;
            const padding = 10;
            ctx.font = '12px Inter';
            const lines = [];
            let currentLine = '';
            const words = text.split(' ');
            for (const word of words) {
                const testLine = currentLine + word + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && currentLine !== '') {
                    lines.push(currentLine.trim());
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine.trim());
            const tooltipHeight = lines.length * lineHeight + padding * 2;
            const tooltipWidth = Math.max(...lines.map(line => ctx.measureText(line).width)) + padding * 2;
            let tooltipX = x + 15;
            let tooltipY = y + 15;
            if (tooltipX + tooltipWidth > canvas.width) { tooltipX = x - tooltipWidth - 15; }
            if (tooltipY + tooltipHeight > canvas.height) { tooltipY = y - tooltipHeight - 15; }
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.rect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            lines.forEach((line, index) => {
                ctx.fillText(line, tooltipX + padding, tooltipY + padding + index * lineHeight);
            });
        }
        
        function drawDebugInfo() {
            ctx.save();
            ctx.font = '10px Inter';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            const lineHeight = 12;
            const startX = 10;
            let startY = canvas.height - 10;
            const statusText = loadedLogoInfo.length > 0 ? 'Geladene Logos:' : 'Keine Logos geladen.';
            ctx.fillStyle = 'white';
            ctx.fillText(statusText, startX, startY - (loadedLogoInfo.length * lineHeight));
            [...loadedLogoInfo].reverse().forEach((info, index) => {
                ctx.fillStyle = info.hasDims ? 'lightgreen' : 'yellow';
                ctx.fillText(`- ${info.name} ${info.hasDims ? '[OK]' : '[NO DIMS]'}`, startX, startY - (index * lineHeight));
            });
            ctx.restore();
        }

        // --- Event Handlers ---
        function handleKeyPress(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                isColorMode = !isColorMode;
                logos.forEach(logo => {
                    logo.currentImage = isColorMode ? logo.imageColor : logo.imageBW;
                });
            }
            if (event.code === 'Enter') {
                event.preventDefault();
                if (isTransitioning) return;
                isTransitioning = true;
                viewMode = viewMode === 'tunnel' ? 'grid' : 'tunnel';
                document.getElementById('ui-overlay').style.opacity = viewMode === 'tunnel' ? 1 : 0;
            }
        }
        
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = event.clientX - rect.left;
            mousePos.y = event.clientY - rect.top;
        }

        function onMouseWheel(event) {
            if (viewMode === 'grid') return;
            const scrollAmount = event.deltaY * SCROLL_SENSITIVITY;
            targetZ += scrollAmount;
            targetZ = Math.max(START_Z, Math.min(END_Z, targetZ));
        }

        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const fov_rad = 75 * Math.PI / 180;
            focalLength = (canvas.height / 2) / Math.tan(fov_rad / 2);
            updateGeometryPositions();
        }
        
        function updateState() {
            if (isTransitioning) {
                const targetProgress = viewMode === 'grid' ? 1 : 0;
                if (Math.abs(transitionProgress - targetProgress) < 0.001) {
                    transitionProgress = targetProgress;
                    isTransitioning = false;
                } else {
                    transitionProgress = lerp(transitionProgress, targetProgress, TRANSITION_SPEED);
                }
            }

            if (transitionProgress < 1) {
                camera.z += (targetZ - camera.z) * EASE_FACTOR;
                const currentYear = zToYear(camera.z);
                const yearElement = document.getElementById('current-year');
                if (yearElement) {
                    const yearToDisplay = Math.round(Math.min(VISUAL_MAX_YEAR, Math.max(MIN_YEAR, currentYear)));
                    yearElement.textContent = yearToDisplay;
                }
            }
        }

        function animate() {
            updateState();
            draw();
            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>

